# SysMonitor
# 개요
- 이 프로그램은 서버와 클라이언트 간의 UDP 통신 방식을 이용한다.
- 클라이언트가 서버의 CPU, 메모리, 디스크 자원 사용률을 요청하면, 서버는 요청을 했던 클라이언트에게 자신의 사용률을 응답으로 제공한다.
- 이 문서에서 사용하는 shell 명령어는 Ubuntu 기준을 따른다.
        
# 빌드
## 빌드 전 준비 사항
- 서버에서 사용하는 헤더 (`src/server.h`)에 정의된 `PORT_NUM`에 맞추어 서버의 UDP 포트를 개방해야 한다.
    - 기본으로 사용하는 포트는 8080번이다.
        ```bash
        sudo ufw allow 8080/udp
        ```
- 빌드 시 `gcc`, `make`가 필요하므로, 설치가 안되어 있다면 설치한다.
    - 설치 방법
        ```bash
        # gcc, g++, make를 한 번에 설치한다.
        sudo apt install build-essential
        ```
    - 정상 설치 여부는 다음 명령어를 통하여 확인한다.
        ```bash
        gcc --version
        make --version
        ```

## 빌드 방법
### 디렉토리 구조
```bash
├── bin
│   ├── modules (서버에서 사용량을 응답하기 위해 사용하는 모듈)
│   │   ├── cpu.so
│   │   ├── mem.so
│   │   └── disk.so
│   ├── obj
│   └── server
├── src
│   ├── modules (사용량 응답 방식을 구체적으로 정의한 소스)
│   │   ├── cpu_module.c
│   │   ├── mem_module.c
│   │   └── disk_module.c
│   ├── common.h (서버 및 모듈에서 공통으로 사용하는 매크로)
│   ├── module.h (모듈 구조를 정의)
│   ├── resource.h (자원 사용량의 실제 값을 갖는 구조체, 값 계산 함수 정의)
│   ├── server.h (서버의 실제 응답 처리 로직 정의)
│   ├── resource.c
│   └── server.c
└── Makefile
``` 

- 프로젝트 루트에 있는 `Makefile`이 보일 것이다.
- `Makefile`을 이용하여 서버 바이너리와 모듈을 빌드할 수 있으며, 사용량 계산에 이용되는 함수들을 묶어둔 정적 라이브러리를 링크할 수 있다.
- 현재 `Makefile` 구조상으로 사용 가능한 명령은 다음과 같다.
    - `make`: 기본 동작으로, 서버 바이너리와 각종 서버 자원의 사용량을 응답할 모듈을 빌드한다.
    - `make server`: 서버 바이너리만 빌드한다.
    - `make modules`: CPU, 메모리, 디스크 사용량을 응답할 모듈들을 모두 빌드한다.
    - `make clean`: `bin` 하의 모든 빌드 결과물들을 삭제한다.
---
# 실행
- 클라이언트와 서버는 동일한 네트워크에 접속 (내부 IP를 통한 통신)
## 클라이언트
- `nc`(netcat)를 이용하여 서버에게 UDP 요청을 전송한다.
    ```bash
    # nc -u ${server_addr} ${port}
    nc -u 172.27.7.152 8080
    ```
- `nc`가 설치되지 않은 경우 다음 명령어를 이용하여 설치한다.
    ```bash
    sudo apt install nc
    ```
- 클라이언트가 요청할 수 있는 자원은 다음과 같다.
    - `cpu`: 서버의 전체 코어, 각 코어별 사용률을 요청한다.
    - `mem`: 서버의 전체 메모리 용량과 `free`, `used` 등 각 영역에 대한 사용량, 사용률을 요청한다.
    - `disk`: 서버의 전체 디스크 파티션별 사용량 및 사용률을 요청한다.
    * 이 외의 요청을 할 경우, 서버 측에서는 오류 메시지를 응답하며, 해당 요청은 무시된다.
## 서버
- `./bin/server`를 실행하여 클라이언트의 요청을 기다린다.
- 가령 `~/sysmonitor` 디렉토리 하에 설치되었다고 하면,
    ```bash
    cd ~/sysmonitor
    ./bin/server
    ```
- 클라이언트의 요청이 `cpu`, `mem`, `disk` 중 하나인 경우, 서버에는 표준 출력(`stdout`)으로 다음 형식의 내용을 남긴다.
    ```
    Sent 710 bytes to client(172.17.0.1) for request 'cpu'.
    ```

---
# 이 프로그램의 구조
서버 프로그램은 `bin/server` 바이너리를 이용하며, `server.c`에 서버의 동작이 구현되어 있다.

## 프로그램의 주요 함수

## `main`
- 서버 프로그램이 시작되면 `main` 함수에 진입한다.
- `initialize_server` 함수에서 이 서버 프로그램의 구성 요소를 초기화한다.
    - 프로그램이 Ctrl+C (`SIGINT`) 에 의해 종료될 경우, 기존에 사용하던 모듈들을 `cleanup_modules` 함수에서 close 하도록 구현
    - UDP 통신을 위한 소켓을 제공받고, 이를 주어진 포트를 이용하여 바인딩한다.

- 초기화 이후, `while` 루프 내에서 `process_request` 함수를 무한히 호출한다.
    - 클라이언트로부터 request를 수신하고, 수신한 request에 따라 해당 클라이언트에게 응답을 제공한다.
    - 반복된 `dlopen`, `dlclose` 호출을 방지하고자, 서버에는 각 자원을 반환하는 모듈에 대한 핸들러 정보를 가지고 있다.
        - 만약 모듈을 처음 사용하는 경우, 최초 1회 `dlopen`을 통하여 핸들러를 가져오고, 이를 저장장해둔다.
        - 이후 반복된 모듈 호출에서는, 저장된 핸들러 정보를 이용하여 응답을 처리한다.
        - 프로그램이 종료될 경우, `cleanup_modules` 함수에서 모든 핸들러를 닫으며 UDP 소켓도 닫고 종료한다.

